<!DOCTYPE HTML>
<html>
   <head>
   	  <meta charset="utf-8" />
      <title>Boingy</title>
      <style type="text/css">
      	body {
      		overflow: hidden;
      		margin: 0px;
      	}
      </style>
   </head>
   <body>
   	 <canvas id="canvas" style="background-color:#333333; display:none;" ></canvas>
   </body>
   <script type="text/javascript" src="js/Box2dWeb-2.1.a.3.min.js"></script>
   <script type="text/javascript" src="js/Three.js"></script>
   <script type="text/javascript" src="js/Stats.js"></script>
   <script type="text/javascript">
   
   var debug = false;
   var drawScale = 15;
   
   var   b2Vec2 = Box2D.Common.Math.b2Vec2
   ,  b2AABB = Box2D.Collision.b2AABB
	,	b2BodyDef = Box2D.Dynamics.b2BodyDef
	,	b2Body = Box2D.Dynamics.b2Body
	,	b2FixtureDef = Box2D.Dynamics.b2FixtureDef
	,	b2Fixture = Box2D.Dynamics.b2Fixture
	,	b2World = Box2D.Dynamics.b2World
	,	b2MassData = Box2D.Collision.Shapes.b2MassData
	,	b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape	
	 ,       b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
   ,   b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef
   ,	b2DebugDraw = Box2D.Dynamics.b2DebugDraw
   ,   b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef
   ;
	   
	   var camera, scene, renderer, stats,
	   geometry, material, mesh;
	   
       var mouseX, mouseY, mousePVec, isMouseDown, selectedBody, mouseJoint;
       var world;
       
       var wallt, wallb, walll, wallr;
       
       var fixDef = new b2FixtureDef;
       fixDef.density = 1.0;
       fixDef.friction = 0.3;
       fixDef.restitution = 0.0;
       
       var bodyDef = new b2BodyDef;
	
	   var boingies = new Array();
	
	   function animate() {
	       requestAnimationFrame( animate );
	       render();
	   }
	
	   function render() {
	
		   if(isMouseDown && (!mouseJoint)) {
               var body = getBodyAtMouse(0.1);
               if(body) {
                  var md = new b2MouseJointDef();
                  md.bodyA = world.GetGroundBody();
                  md.bodyB = body;
                  md.target.Set(mouseX, mouseY);
                  md.collideConnected = true;
                  md.maxForce = 700.0;
                  mouseJoint = world.CreateJoint(md);
                  body.SetAwake(true);
               } else {
            	   var bs = 5;
            	   var hbs = bs/2;
            	   if(!getBodyAtMouse(hbs)) {
	            	  var v = new b2Vec2(mouseX, mouseY)
	            	  if(v.x > hbs && v.y > hbs && v.x < window.innerWidth / drawScale - hbs && v.y < window.innerHeight / drawScale - hbs) {
	            	  	if(Math.random() > 0.5) {
	            			createSquareBoingy(v.x-hbs,v.y-hbs,bs,bs);
	            	  	} else {
	            			createRoundBoingy(v.x-hbs,v.y-hbs,hbs,20);
	            	  	}
	            	  }
            	   }	
               }
            }
            
            if(mouseJoint) {
               if(isMouseDown) {
                  mouseJoint.SetTarget(new b2Vec2(mouseX, mouseY));
               } else {
                  world.DestroyJoint(mouseJoint);
                  mouseJoint = null;
               }
            }
         
            world.Step(1 / 60, 10, 10);
            if(debug) {
            	world.DrawDebugData();
            } else {
               updateBoingeGeo();
     	       renderer.render( scene, camera );
            }
   		    stats.update();
            world.ClearForces();
            
	
	   }
	   
	   function updateBoingeGeo() {
		   for(var a in boingies) {
			   var bb = boingies[a];
			   var vs = bb.mesh.geometry.vertices;
			   
			   if(bb.type == "square") {
				   var i,b,wc,dx,dy,xl,yl,cc,xm,ym;
				   xl = bb.bodies.length;
				   yl = bb.bodies[0].length;
				   cc = bb.bodies[Math.floor(xl/2)][Math.floor(yl/2)].GetPosition();
				   xm = (1/xl)*0.8;
				   ym = (1/yl)*0.8;
				   for(var x = 0; x < xl; ++x) {
					    
					    
			         	for(var y = 0; y < yl; ++y) {
			         		i = xl*y+x;
			         		b = bb.bodies[x][y];
			         		wc = b.GetPosition();
			         		vs[i].x = (wc.x+(wc.x-cc.x)*xm)*drawScale;
							vs[i].z = (wc.y+(wc.y-cc.y)*ym)*drawScale;
			         	}
					}
				   
				   
			   } else if(bb.type == "round") {
				   var l = vs.length;
				   var bl = bb.bodies.length;
				   var cc = bb.bodies[0].GetPosition();
				   var wc,bi;
				   for(var i = 0; i < l; i++) {
					   if(i < 20) {
						   bi = i+1;
					   } else if(i == 20 || i == 41) {
						   bi = 1;
					   } else if(i >= 21 && i <= 40) {
						   bi = i - 20;
					   } else if(i >= 42) {
						   bi = 0;
					   }
					   wc = bb.bodies[bi].GetPosition();
					   vs[i].x = (wc.x+(wc.x-cc.x)*0.13)*drawScale;
					   vs[i].z = (wc.y+(wc.y-cc.y)*0.13)*drawScale;
				   }
			   }
			   bb.mesh.geometry.verticesNeedUpdate = true;
		   }
			   
	   }
	   
	   document.addEventListener("mousedown", function(e) {
           isMouseDown = true;
           handleMouseMove(e);
           document.addEventListener("mousemove", handleMouseMove, true);
        }, true);
        
        document.addEventListener("mouseup", function() {
           document.removeEventListener("mousemove", handleMouseMove, true);
           isMouseDown = false;
           mouseX = undefined;
           mouseY = undefined;
        }, true);
        
        function handleMouseMove(e) {
           mouseX = e.clientX / drawScale;
           mouseY = e.clientY / drawScale;
        };
        
        function getBodyAtMouse(ss) {
           mousePVec = new b2Vec2(mouseX, mouseY);
           var aabb = new b2AABB();
           aabb.lowerBound.Set(mouseX - ss, mouseY - ss);
           aabb.upperBound.Set(mouseX + ss, mouseY + ss);
           
           selectedBody = null;
           world.QueryAABB(getBodyCB, aabb);
           return selectedBody;
        }

        function getBodyCB(fixture) {
           if(fixture.GetBody().GetType() != b2Body.b2_staticBody) {
                selectedBody = fixture.GetBody();
                return false;
           }
           return true;
        }
        
        function createSpringJoint(b1, b2, collide, freq, damp) {
        	var j = new b2DistanceJointDef();
      		j.Initialize(b1, b2, b1.GetWorldCenter(), b2.GetWorldCenter());
      		j.collideConnected = collide;
      		j.frequencyHz = freq;
      		j.dampingRatio = damp;
      		world.CreateJoint(j);
         }; 
        
        function createSquareBoingy(xx, yy, bSizeX, bSizeY) {
	         var bodies = new Array();
	         bodyDef.type = b2Body.b2_dynamicBody;
	         for(var x = 0; x < bSizeX; ++x) {
	        	bodies.push(new Array());
	        	for(var y = 0; y < bSizeY; ++y) {
	        		
		            fixDef.shape = new b2PolygonShape;
		            fixDef.shape.SetAsBox(0.3, 0.3);
		            bodyDef.position.x = x+xx;
		            bodyDef.position.y = y+yy;
		            bodyDef.fixedRotation = true;
		            var body = world.CreateBody(bodyDef);
		            body.CreateFixture(fixDef);
		            bodies[x][y] = body;
	        	}
	         }
	         
	         for(var x = 0; x < bSizeX; ++x) {
	         	for(var y = 0; y < bSizeY; ++y) {
	         		var cc = true;//(x > 0 && x < bSizeX - 1 && y > 0 && y < bSizeY - 1);
	         		if(x < bSizeX - 1 && y < bSizeY - 1) {
		         		createSpringJoint(bodies[x][y], bodies[x+1][y], cc, 7.0, 0.2); 
		         		createSpringJoint(bodies[x][y], bodies[x][y+1], cc, 7.0, 0.2);
		         		createSpringJoint(bodies[x][y], bodies[x+1][y+1], cc, 7.0, 0.2);
	         		}
	         		if(x > 0 && y < bSizeY - 1) {
	         			createSpringJoint(bodies[x][y], bodies[x-1][y+1], cc, 7.0, 0.2);
	         		}
	         		if (x == bSizeX - 1 && y < bSizeY - 1) {
	         			createSpringJoint(bodies[x][y], bodies[x][y+1], cc, 7.0, 0.2);
	         		} 
	         		if (x < bSizeX - 1 && y == bSizeY - 1) {
	         			createSpringJoint(bodies[x][y], bodies[x+1][y], cc, 7.0, 0.2);
	         		}
	         	}
	         }
	         
	         var geo = new THREE.PlaneGeometry(bSizeX*drawScale,bSizeY*drawScale,bSizeX-1,bSizeY-1);
	         geo.dynamic = true;
	         mesh = new THREE.Mesh(geo , squareMaterial );
	         mesh.rotation.x = Math.PI/2;
	         mesh.position.z = boingies.length;
	         scene.add( mesh );
	     	 boingies.push({mesh: mesh, bodies: bodies, type: 'square'})    
        }
        
        function createRoundBoingy(xx, yy, radius, numSeg) {
   	        var bodies = new Array();
   		    bodyDef.type = b2Body.b2_dynamicBody;
   		    
	   		 fixDef.shape = new b2CircleShape(radius*0.4);
	         bodyDef.position.x = xx;
	         bodyDef.position.y = yy;
	         var body = world.CreateBody(bodyDef);
	         body.CreateFixture(fixDef);
	         bodies.push(body);
	         
	         for(var i = 0 ; i < numSeg; i++) {
	        	 fixDef.shape = new b2CircleShape(radius*0.15);
		         bodyDef.position.x = xx + Math.cos(i/numSeg*Math.PI*2)*radius;
		         bodyDef.position.y = yy + Math.sin(i/numSeg*Math.PI*2)*radius;
		         var body = world.CreateBody(bodyDef);
		         body.CreateFixture(fixDef);
		         bodies.push(body);
	         }
	         for(var i = 1 ; i < numSeg+1; i++) {
	        	 createSpringJoint(bodies[i], bodies[0], true, 7.0, 0.1);
	        	 if(i == 1) {
	        		 createSpringJoint(bodies[i], bodies[numSeg], false, 10.0, 0.9);
	        	 } else {
	        		 createSpringJoint(bodies[i], bodies[i-1], false, 10.0, 0.9);
	        	 }
	         }
	         
	         var geo = new THREE.CylinderGeometry( radius*drawScale, radius*drawScale, 1, numSeg, 0, false );
	         
	         var radius_whole = radius*drawScale;
	         var radius_half = radius / 2;
	         for ( var z = 0; z < geo.faces.length; z ++ ) {
	             if ( geo.faces[ z ] instanceof THREE.Face3 ) {
	            	 geo.faceVertexUvs[ 0 ][ z ][ 0 ].u = ( geo.vertices[ geo.faces[ z ].a ].x + radius_half ) / radius_whole;
	            	 geo.faceVertexUvs[ 0 ][ z ][ 0 ].v = ( geo.vertices[ geo.faces[ z ].a ].z + radius_half ) / radius_whole;
	            	 geo.faceVertexUvs[ 0 ][ z ][ 1 ].u = ( geo.vertices[ geo.faces[ z ].b ].x + radius_half ) / radius_whole;
	            	 geo.faceVertexUvs[ 0 ][ z ][ 1 ].v = ( geo.vertices[ geo.faces[ z ].b ].z + radius_half ) / radius_whole;
	            	 geo.faceVertexUvs[ 0 ][ z ][ 2 ].u = ( geo.vertices[ geo.faces[ z ].c ].x + radius_half ) / radius_whole;
	            	 geo.faceVertexUvs[ 0 ][ z ][ 2 ].v = ( geo.vertices[ geo.faces[ z ].c ].z + radius_half ) / radius_whole;
	             }
	         }
	         
	         geo.dynamic = true;
	         mesh = new THREE.Mesh(geo , roundMaterial );
	         mesh.rotation.x = Math.PI/2;
	         mesh.position.z = boingies.length;
	         scene.add( mesh );
	     	 boingies.push({mesh: mesh, bodies: bodies, type: 'round'})    
	         
        }
        
    	window.addEventListener('resize', function(){
    		renderer.setSize( window.innerWidth, window.innerHeight );
    		camera.right = window.innerWidth;
    		camera.bottom = -window.innerHeight;
    		camera.updateProjectionMatrix();
    		
    		wallb.SetPosition(new b2Vec2(0, window.innerHeight / drawScale + 2));
    		wallr.SetPosition(new b2Vec2(window.innerWidth / drawScale+2.1, 0));
    	}, false);
      
        window.onload = function() {
    	  
    	  scene = new THREE.Scene();
    		
    	  camera = new THREE.OrthographicCamera( 0, window.innerWidth , 0, -window.innerHeight, -1000, 1000 );
	  		camera.position.x = 0;
	  		camera.position.y = 0;
	  		camera.position.z = 1;
	       scene.add( camera );
	
	       
	       var roundTex = THREE.ImageUtils.loadTexture("crate.jpg");
	       roundTex.wrapS = roundTex.wrapT = THREE.MirroredRepeatWrapping;
	       roundMaterial = new THREE.MeshLambertMaterial({ map: roundTex });
	       squareMaterial = new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture("crate.jpg") });
	
	        scene.add(new THREE.AmbientLight(0xFFFFFF));
	        
	       renderer = new THREE.WebGLRenderer({
	    	   antialias: true
	       });
	       renderer.setSize( window.innerWidth, window.innerHeight );
	
	       document.body.appendChild( renderer.domElement );
         
         world = new b2World( new b2Vec2(0, 10), true );
         
         stats = new Stats();
     	stats.domElement.style.position = 'absolute';
     	stats.domElement.style.top = '0px';
     	document.body.appendChild( stats.domElement );
         
         //create ground
         bodyDef.type = b2Body.b2_staticBody;
         fixDef.shape = new b2PolygonShape;
         fixDef.shape.SetAsBox(1000, 2);
         
         bodyDef.position.Set(0, window.innerHeight / drawScale + 2.1);
         wallb = world.CreateBody(bodyDef);
         wallb.CreateFixture(fixDef);
         
         bodyDef.position.Set(0, -2.1);
         wallt = world.CreateBody(bodyDef);
         wallt.CreateFixture(fixDef);
         
         fixDef.shape.SetAsBox(2, 1000);
         
         bodyDef.position.Set(-2.1, 0);
         walll = world.CreateBody(bodyDef);
         walll.CreateFixture(fixDef);
         
         bodyDef.position.Set(window.innerWidth / drawScale+2.1, 0);
         wallr = world.CreateBody(bodyDef);
         wallr.CreateFixture(fixDef);

         createSquareBoingy(window.innerWidth / drawScale / 2 - 3.5, window.innerHeight / drawScale / 2 - 3.5, 7, 7);
         createRoundBoingy(window.innerWidth / drawScale / 2, window.innerHeight / drawScale - 7, 2.5, 20)
         
         if(debug) {
        	//setup debug draw
        	 var canvas = document.getElementById("canvas");
        	 canvas.style.display = "block";
        	 canvas.width = window.innerWidth;
        	 canvas.height = window.innerHeight;
             var debugDraw = new b2DebugDraw();
             debugDraw.SetSprite(canvas.getContext("2d"));
             debugDraw.SetDrawScale(drawScale);
             debugDraw.SetFillAlpha(0.5);
             debugDraw.SetLineThickness(1.0);
             debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
             world.SetDebugDraw(debugDraw);
         }
         
         var textureImg = new Image();
         textureImg.onload = function(){
             animate();
         };
         textureImg.src = "crate.jpg";
         


         
      };
      
      
   
   </script>
   
   
</html>